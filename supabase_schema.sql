
-- ### POLYMARKET SUPABASE SCHEMA ###
-- Run this entire script in your Supabase SQL Editor to set up the database.

-- 1. Create the 'markets' table
-- This table stores all prediction markets, both standard and MCAP target types.
CREATE TABLE IF NOT EXISTS public.markets (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    question text NOT NULL,
    image text,
    description text,
    yes_votes integer NOT NULL DEFAULT 0,
    no_votes integer NOT NULL DEFAULT 0,
    contract_address text,
    option_a text DEFAULT 'YES'::text,
    option_b text DEFAULT 'NO'::text,
    market_type text NOT NULL DEFAULT 'STANDARD'::text,
    target_market_cap numeric,
    expires_at timestamp with time zone,
    status text NOT NULL DEFAULT 'OPEN'::text,
    CONSTRAINT markets_pkey PRIMARY KEY (id)
);

-- 2. Create the 'comments' table
-- This table stores user comments for each market.
CREATE TABLE IF NOT EXISTS public.comments (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    market_id bigint NOT NULL,
    username text NOT NULL,
    content text NOT NULL,
    CONSTRAINT comments_pkey PRIMARY KEY (id),
    CONSTRAINT comments_market_id_fkey FOREIGN KEY (market_id) REFERENCES public.markets(id) ON DELETE CASCADE
);

-- 3. Create the RPC function for voting
-- This function handles the logic for casting, changing, and tallying votes atomically.
-- It prevents race conditions and ensures data integrity.
-- SECURITY DEFINER allows this function to run with the privileges of the user who created it, bypassing RLS for table updates.
CREATE OR REPLACE FUNCTION public.vote_market(p_market_id integer, p_vote_type text, p_previous_vote text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- If there was a previous vote, decrement the old counter
  IF p_previous_vote IS NOT NULL THEN
    IF p_previous_vote = 'YES' THEN
      UPDATE markets SET yes_votes = yes_votes - 1 WHERE id = p_market_id;
    ELSIF p_previous_vote = 'NO' THEN
      UPDATE markets SET no_votes = no_votes - 1 WHERE id = p_market_id;
    END IF;
  END IF;

  -- Increment the new vote counter
  IF p_vote_type = 'YES' THEN
    UPDATE markets SET yes_votes = yes_votes + 1 WHERE id = p_market_id;
  ELSIF p_vote_type = 'NO' THEN
    UPDATE markets SET no_votes = no_votes + 1 WHERE id = p_market_id;
  END IF;
END;
$function$;

-- 4. Enable Row Level Security (RLS) for all tables
-- This is a crucial security step.
ALTER TABLE public.markets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;

-- 5. Create RLS policies
-- These policies define who can access or modify the data.
-- We will allow public read and insert access for this application.

-- Drop existing policies to ensure a clean slate
DROP POLICY IF EXISTS "Enable public read access for all users" ON public.markets;
DROP POLICY IF EXISTS "Enable insert for all users" ON public.markets;
DROP POLICY IF EXISTS "Enable public read access for all users" ON public.comments;
DROP POLICY IF EXISTS "Enable insert for all users" ON public.comments;

-- Create new policies
CREATE POLICY "Enable public read access for all users" ON public.markets
AS PERMISSIVE FOR SELECT
TO public
USING (true);

CREATE POLICY "Enable insert for all users" ON public.markets
AS PERMISSIVE FOR INSERT
TO public
WITH CHECK (true);

CREATE POLICY "Enable public read access for all users" ON public.comments
AS PERMISSIVE FOR SELECT
TO public
USING (true);

CREATE POLICY "Enable insert for all users" ON public.comments
AS PERMISSIVE FOR INSERT
TO public
WITH CHECK (true);